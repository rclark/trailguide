// Generated by CoffeeScript 1.6.1
(function() {
  var app, collections, models, root, views, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  root = this;

  app = (_ref = root.trailapp) != null ? _ref : root.trailapp = {};

  models = (_ref1 = app.models) != null ? _ref1 : app.models = {};

  collections = (_ref2 = app.collections) != null ? _ref2 : app.collections = {};

  models.GeoDataModel = (function(_super) {

    __extends(GeoDataModel, _super);

    function GeoDataModel() {
      return GeoDataModel.__super__.constructor.apply(this, arguments);
    }

    /*This is a base class for GeoJSON data pulled from Trailguide API
    */


    GeoDataModel.prototype.modelName = "Trail Data";

    /*
    Proper REST-ful architecture would have us maintain the GeoJSON "id" attribute as the URI for the resource -- in our
    case, that would be the URL that we access it on via API call. But this will confuse Backbone, as the entire URI
    would be appended to the urlRoot resulting in invalid API calls. Instead, the GeoJSON objects returned via API will
    include a "pk" property, which Backbone will treat as the ID.
    */


    GeoDataModel.prototype.idAttribute = "pk";

    GeoDataModel.prototype.parse = function(response, options) {
      /*
      From Backbone.js docs:
      "parse is called whenever a model's data is returned by the server, in fetch, and save. The function is passed the
      raw response object, and should return the attributes hash to be set on the model."
      
      GeoJSON puts attributes in a 'properties' object, so we need to pull that out here for fetch to work as we expect
      
      @response: GeoJSON object retrieved by a fetch or save
      @options: unknown...
      */

      var geometry, properties;
      properties = response.properties || {};
      geometry = response.geometry || {};
      return _.extend({}, properties, {
        geometry: geometry
      });
    };

    GeoDataModel.prototype.toJSON = function() {
      /*
      From Backbone.js docs:
      "Return a copy of the model's attributes for JSON stringification."
      
      Put the attributes hash in the right place to create a valid GeoJSON object
      */

      var geojson;
      return geojson = {
        type: "Feature",
        id: this.id,
        properties: _.omit(this.attributes, "geometry"),
        geometry: this.get("geometry")
      };
    };

    return GeoDataModel;

  })(Backbone.Model);

  collections.GeoDataCollection = (function(_super) {

    __extends(GeoDataCollection, _super);

    function GeoDataCollection() {
      return GeoDataCollection.__super__.constructor.apply(this, arguments);
    }

    /*A base class for GeoJSON data collections from the Trailguide API
    */


    GeoDataCollection.prototype.model = models.GeoDataModel;

    GeoDataCollection.prototype.url = function() {
      /*Generate the URL for the API calls to this data set
      */
      return "/api/" + this.model.prototype.modelName;
    };

    GeoDataCollection.prototype.parse = function(response, options) {
      /*
      From Backbone docs:
      "parse is called by Backbone whenever a collection's models are returned by the server, in fetch. The function is
      passed the raw response object, and should return the array of model attributes to be added to the collection."
      
      We will get back a GeoJSON FeatureCollection, and need to pull our the individual GeoJSON objects in order to create
      models
      
      @response: This will be a GeoJSON object returned by the Trailguide API
      @options: unknown
      */
      return response.features || [];
    };

    GeoDataCollection.prototype.toGeoJSON = function() {
      /*
      Create a GeoJSON FeatureCollection from the data in this model. Useful for generating map layers
      */

      var featureCollection, m;
      return featureCollection = {
        type: "FeatureCollection",
        features: (function() {
          var _i, _len, _ref3, _results;
          _ref3 = this.models;
          _results = [];
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            m = _ref3[_i];
            _results.push(m.toJSON());
          }
          return _results;
        }).call(this)
      };
    };

    return GeoDataCollection;

  })(Backbone.Collection);

  models.SegmentModel = (function(_super) {

    __extends(SegmentModel, _super);

    function SegmentModel() {
      return SegmentModel.__super__.constructor.apply(this, arguments);
    }

    SegmentModel.prototype.modelName = "segment";

    return SegmentModel;

  })(models.GeoDataModel);

  collections.SegmentCollection = (function(_super) {

    __extends(SegmentCollection, _super);

    function SegmentCollection() {
      return SegmentCollection.__super__.constructor.apply(this, arguments);
    }

    SegmentCollection.prototype.model = models.SegmentModel;

    return SegmentCollection;

  })(collections.GeoDataCollection);

  /* --------------------------------------------
       Begin layer-models.coffee
  --------------------------------------------
  */


  root = this;

  app = (_ref3 = root.trailapp) != null ? _ref3 : root.trailapp = {};

  models = (_ref4 = app.models) != null ? _ref4 : app.models = {};

  collections = (_ref5 = app.collections) != null ? _ref5 : app.collections = {};

  models.MapLayer = (function(_super) {

    __extends(MapLayer, _super);

    function MapLayer() {
      return MapLayer.__super__.constructor.apply(this, arguments);
    }

    /*Base class for any map layers
    */


    MapLayer.prototype.defaults = {
      name: "Layer's Name",
      isLayerReady: false,
      visible: false,
      selectable: false
    };

    MapLayer.prototype.initialize = function(options) {
      var thisLayerModel;
      this.options = options;
      thisLayerModel = this;
      this.on("layerReady", function() {
        return thisLayerModel.set("isLayerReady", true);
      });
      return this.set("mapLayer", this.createMapLayer());
    };

    MapLayer.prototype.createMapLayer = function() {
      /*
      This function should be overridden by child models and should produce an object that can be added to the map. There
      is some conflation of data and portrayal here, since the object produced will depend on the type of map that we're
      adding the thing to. We're pretty wedded to Leaflet though, so we might be able to get away with this
      */

      var l;
      l = {};
      this.trigger("layerReady", l);
      return l;
    };

    return MapLayer;

  })(Backbone.Model);

  models.GeoJsonMapLayer = (function(_super) {

    __extends(GeoJsonMapLayer, _super);

    function GeoJsonMapLayer() {
      return GeoJsonMapLayer.__super__.constructor.apply(this, arguments);
    }

    /*Class that generates an L.GeoJSON layer from data via JSON request
    */


    GeoJsonMapLayer.prototype.createMapLayer = function() {
      /*
      This function needs to end up setting the model's "mapLayer" attribute, and triggering the "layerReady" event. Since
      the call for GeoJSON via collection.fetch is asynchronous, we listen for custom events.
      */
      this.on("dataFetch.success", function(dataCollection) {
        var layer;
        layer = new L.GeoJSON(dataCollection.toGeoJSON());
        this.set("mapLayer", layer);
        return this.trigger("layerReady", layer);
      });
      this.on("dataFetch.error", function(response) {
        return console.log(response);
      });
      return this.getData();
    };

    GeoJsonMapLayer.prototype.getData = function() {
      /*
      Get data from the server through the embedded Backbone.Collection.fetch(). Fire events upon asynchronous completion.
      */

      var collection, thisLayerModel;
      thisLayerModel = this;
      collection = this.get("data");
      if (collection == null) {
        this.trigger("dataFetch.error", "No GeoDataCollection was given to this GeoJsonMapLayer");
        null;
      }
      return collection.fetch({
        success: function(collection, response, options) {
          return thisLayerModel.trigger("dataFetch.success", collection);
        },
        error: function(collection, response, options) {
          return thisLayerModel.trigger("dataFetch.error", response);
        }
      });
    };

    return GeoJsonMapLayer;

  })(models.MapLayer);

  models.MapboxLayer = (function(_super) {

    __extends(MapboxLayer, _super);

    function MapboxLayer() {
      return MapboxLayer.__super__.constructor.apply(this, arguments);
    }

    /*Class that generates an L.TileLayer from MapBox
    */


    MapboxLayer.prototype.createMapLayer = function() {
      var code, layer;
      code = this.get("code");
      if (code == null) {
        console.log("Tried to create a MapBox layer without specifying its ID");
        null;
      }
      layer = new L.TileLayer("http://a.tiles.mapbox.com/v3/" + code + "/{z}/{x}/{y}.png");
      this.trigger("layerReady", layer);
      return layer;
    };

    return MapboxLayer;

  })(models.MapLayer);

  models.StamenLayer = (function(_super) {

    __extends(StamenLayer, _super);

    function StamenLayer() {
      return StamenLayer.__super__.constructor.apply(this, arguments);
    }

    /*Class that generates a tile layer from Stamen Design
    */


    StamenLayer.prototype.createMapLayer = function() {
      var layer, mapName;
      mapName = this.get("mapName");
      if ((mapName == null) || (mapName !== "terrain" && mapName !== "watercolor" && mapName !== "toner")) {
        console.log("Tried to create a Stamen Designs map without specifying an appropriate mapName");
        null;
      }
      layer = new L.StamenTileLayer(mapName);
      this.trigger("layerReady", layer);
      return layer;
    };

    return StamenLayer;

  })(models.MapLayer);

  /* --------------------------------------------
       Begin map-app.coffee
  --------------------------------------------
  */


  root = this;

  app = (_ref6 = root.trailapp) != null ? _ref6 : root.trailapp = {};

  views = (_ref7 = app.views) != null ? _ref7 : app.views = {};

  views.TrailMap = (function(_super) {

    __extends(TrailMap, _super);

    function TrailMap() {
      return TrailMap.__super__.constructor.apply(this, arguments);
    }

    TrailMap.prototype.initialize = function(options) {
      this.layers = options.layers || [];
      return this.setupMap();
    };

    TrailMap.prototype.setupMap = function() {
      var addLayer, map;
      this.map = map = new L.Map(this.el.id, {
        center: new L.LatLng(32.30280417394316, -110.85685729980469),
        zoom: 11,
        maxBounds: new L.LatLngBounds([[31.9592, -111.286], [32.9085, -110.1283]]),
        minZoom: 11,
        maxZoom: 15
      });
      addLayer = this.addLayer;
      return _.each(this.layers, function(layerModel) {
        if (layerModel.get("isLayerReady")) {
          return map.addLayer(layerModel.get("mapLayer"));
        } else {
          return layerModel.on("layerReady", function(layer) {
            return map.addLayer(layer);
          });
        }
      });
    };

    TrailMap.prototype.addLayer = function(layerModel) {
      return this.map.addLayer(layerModel.get("mapLayer"));
    };

    TrailMap.prototype.removeLayer = function(layerModel) {
      return this.map.removeLayer(layerModel.get("mapLayer"));
    };

    return TrailMap;

  })(Backbone.View);

  trailapp.trailMap = new views.TrailMap({
    el: $("#map"),
    layers: [
      new app.models.MapboxLayer({
        code: "rclark.trails"
      }), new app.models.MapboxLayer({
        code: "rclark.map-gbal2acz"
      }), new app.models.GeoJsonMapLayer({
        data: new app.collections.SegmentCollection()
      })
    ]
  });

}).call(this);
